---
title: "JVM内存区域与内存一处异常笔记"
subtitle: ""
layout: post
author: "Geooo"
header-img: ""
header-style: text
tags:
  - JVM
  - Java
  
---

# 深入理解JVM第2章笔记

## 2.1 概述

本章介绍Java虚拟机内存的各个区域，讲解这些区域的作用、服务对象及可能产生的问题



### 2.2 运行时数据区域



#### 程序计数器

- 字节码行号（偏移量）指示器
- 线程私有
- 执行native方法时，计数器值为空（undefined）
- 唯一在JVM规范中没有规定任何OutOfMemeryError (OOM) 的区域



#### Java虚拟机栈

- 线程私有，生命周期与线程相同
- 每个方法执行时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态连接，方法入口等信息
- 该区域若线程请求栈的深度大于虚拟机所允许的深度，则抛出 StackOverflowError
- 在该区域虚拟机栈动态扩展时无法申请到足够的内存时，则抛出 OutOfMemoryError（OOM）



#### 本地方法栈

- 与虚拟机栈类似，用于执行本地（native）方法
- HotSpoot虚拟机中，本地方法栈与虚拟机栈合二为一



#### 方法区

- 线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、及时编译器编译后的代码缓存等数据
- JDK8以前（不包含8），HotSpot虚拟机通过**永久代**来实现方法区。到了JDK8后，使用**元空间**的方式实现方法区（不能说元空间代替方法区，应该说方法区的实现从 '永久代' 转换成 '元空间' 的实现）
- JDK7时，HotSpot将字符串常量池、静态变量等移除永久代（存放到堆上）
- 方法区无法满足新的内存分配的时候也会抛出OutOfMemoryError（OOM）



##### 运行时常量池

- 方法区的一部分
- Class文件中的常量池表在类加载时放入方法区中



#### 直接内存

- JDK1.4中引用的NIO类可以使用native函数库直接分配堆外内存
- 各个内存区域总和大于物理内存限制时就会抛出OutOfMemoryError
- 元空间（MetaSpace）的内存区域属于直接内存



### 2.3 HotSpot虚拟机对象探秘



#### 对象的创建

- 类未被加载，先执行类加载过程
- 接下来虚拟机为新对象分配内存，有两种方式：**指针碰撞** & **空闲列表**，采用哪种分配内存策略取决于内存是否规整。 

##### 指针碰撞

JVM堆中内存规整的时候为新对象分配内存会选用指针碰撞方式进行分配。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。如果Java堆中内存时绝对规整的，所有被使用过的内存都会被放到一边，空闲的内存放到另外一边，中间放着一个**指针作为分界点**的指示器，所分配内存仅仅时把那个指针向空闲空间方向挪动一段与实例对象大小相等的空间，这种分配方式就是**指针碰撞**。

![](https://img-blog.csdnimg.cn/20201130155644621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JkX3dfY3Nkbg==,size_16,color_FFFFFF,t_70#pic_center)



##### 空闲列表

如果Java堆内存中内存并不是规整的，已被使用的内存和空闲内存相互交错在一起，就不可以进行指针碰撞进行分配了，虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候，从列表中找到一块大于对象实例大小的空间分配给实例对象，并更新列表上的记录，这种分配方式叫**空闲列表**。



