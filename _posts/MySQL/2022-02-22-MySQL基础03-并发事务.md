---
title: "MySQL基础02-MySQL并发事务"
subtitle: ""
layout: post
author: "Geooo"
header-img: ""
header-style: text
tags:
  - MySQL
  
---

## 事务特性(ACID)

### 原子性 Atomicity
一个事务的一些列操作都是原子性，要不都执行，要不都回滚。

### 一致性 Consistency
事务要保证数据库数据的完整性和业务数据的一致性，事务成功提交时则整体数据修改，事务错误则回滚到数据原来的状态。

### 隔离性 Isolation
事务与事务之间都是相互独立互不影响的，多个事务操作一个对象时会以串行等待的方式保证事务之间是隔离的。

### 持久性 Durability
一旦事务提交了就会把对事物的修改进行持久化，不会因为数据库宕机导致数据丢失

## 事务并发导致的问题

### 脏读
在事务并发时，一个事务可以读取到另一个正在进行的事务的数据，导致脏读问题
**解决方法**：将事务隔离级别置为 "读已提交"
![](https://pic3.zhimg.com/80/v2-b32fbf6d7f0d635c17650be9be5085c2_720w.jpg)

### 不可重复读
在事务并发的时候，一个事务里对同一个数据进行读取，但是读取到的数据是不一样的，这种成为"不可重复读"
**解决方法**：将事务隔离级别置为 "可重复读"
![](https://pic4.zhimg.com/80/v2-be6fbff60634326c7e90dec6c22faa77_720w.jpg)

### 幻读
在事务并发的时候，一个事务执行一个范围读取，但是在后面的读取读取到比上一次更多的数据，就好像凭空产生，这种叫幻读。
**解决方法**：
- 将事务隔离级别置为 "串行化"
- 加 **间隙锁 Gap Lock**
**(幻读的本质在于，没有对查询范围内的数据进行加锁，包括不存在的数据，从而导致其他事务可以在这个范围内进行数据插入，所以对表加上间隙锁，可以将这个范围的数据都锁上，其他事务要在这个范围添加数据的时候就会被阻塞，等待加锁事务完成再进行数据插入)**
![](https://pic2.zhimg.com/80/v2-683a5a12de2500448f4b75d2c44f1e35_720w.png)


## 事务隔离级别

### 读未提交 (READ_UNCOMMITTED)
事务读取：不加锁
事务写入：加写锁
解决问题：脏写
存在问题：脏读，不可重复度，幻读

### 读已提交（READ_COMMITTED）
事务读取：每次select完都释放读锁
事务写入：加写锁
解决问题：脏写，脏读
存在问题：不可重复度，幻读

### 可重复度（REPEATABLE_READ）
事务读取：每次select完不会释放读锁，只会在commit的时候才释放。(InnoDB对范围查询还加了间隙锁)
事务写入：加写锁
解决问题：脏写，脏读，不可重复读，幻读(MySQL的InnoDB才解决了幻读)
存在问题：幻读（如果是Mysql的innodb则不存在）。

### SERIALIZABLE
不管读取还是修改所有的事务串行化执行，一个事务的执行必须等其他事务结束

## MySQL的锁

### 一、加锁的目的是什么？
数据库的锁是为了解决事务的隔离性问题，为了让事务之间相互不影响，每个事务进行操作的时候都会对数据加上一把特有的锁，防止其他事务同时操作数据。

### 二、锁是基于什么实现的？
在MySQL数据库中的锁是基于索引实现的，当SQL命中索引时，那锁主的是命中条件中索引节点（行锁），如果没有命中则锁住全表。

### 三、锁的分类
MySQL中锁的分类可以根据其相关性进行分类：

- 基于锁的属性分类：共享锁、排他锁
- 基于锁的粒度分类：行锁、表锁、记录锁、间隙锁、临键锁
- 基于锁的状态分类：意向共享锁、意向排他锁

#### 1.属性锁

##### 共享锁（Share Lock）
共享锁又称读锁，简称S锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。
![](https://pic1.zhimg.com/80/v2-a251449b6e3181eb7e722946787ec298_720w.png)

##### 排他锁（eXclusive Lock）
排他锁又称写锁，简称X锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。

#### 2.粒度锁

##### 表锁






