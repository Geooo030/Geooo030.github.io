---
title: "计算机网络"
subtitle: ""
layout: post
author: "Geooo"
header-img: ""
header-style: text
tags:
  - 计算机网络
  
---


1. TCP 断开连接要几次挥手? 过程是怎么样的? 为什么要四次挥手? Time wait 发生在哪里? 21. 如果有大量的 TCP 处于 time wait 状态会产生什么问题? 怎么解决?
答：
① 因为TCP是**半关闭**的(一方关闭连接的同时，另一方还可以继续放松数据)。所以需要四次挥手。客户端和服务端都可以主动发起关闭请求。
场景：当服务端处理完业务数据后主动关闭socket连接请求(主动方-服务端 | 被动方-客户端)
- 第一次：服务端主动发送**FIN报文**请求关闭，控制位：FIN = 1，序列号req = x。此时服务端的状态更改为 **FIN_WAIT1**.
- 第二次：客户端接收到发送的FIN报文后，回应服务端一个**ACK报文** 表示接收到关闭请求，但是还需要发送数据，此时客户端状态变为 **CLOSE_WAIT**
- 第三次：等待客户端将所有数据都发送完后，会再次发送一个**FIN报文**给服务端向客户端说已经发送完毕可以进行关闭连接了，此时客户端状态变为 **LAST_ACK**。
- 第四次：服务端收受客户端发送的FIN报文后，回应最后一个ACK，把客户端发来的序列号+1作为应答ack值，此时服务端状态为：**TIME_WAIT**。客户端接收到最后的ACK后就会关闭连接。

② TIME_WAIT发生在第四次挥手，就是服务端给客户端发送最后一个ACK时，服务端会置为 TIME_WAIT 状态。TIME_WAIT状态并不会立刻变成 CLOSE状态，而是会等待2msl时间才转化成 CLOSE，确保客户端已经收到了服务端的LAST ACK才会进行关闭。
(2msl:一个报文的来回时间，如果客户端在规定时间没收到LAST ACK，客户端会重新发送FIN报文给服务端，服务端就知道自己之前LAST ACK丢失了，然后再发送一次)

产生大量的TIME_WAIT状态**原因**：
在**高并发短连接**的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。

解决:
- 

