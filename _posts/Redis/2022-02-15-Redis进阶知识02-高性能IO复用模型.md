---
title: "Redis进阶02-Redis高性能IO复用模型? "
subtitle: ""
layout: post
author: "Geooo"
header-img: ""
header-style: text
tags:
  - Redis
  
---

# Redis高性能IO复用模型

## "单线程" Redis

我们通常说Redis是单线程，指的是 **Redis在进行网络IO和键值对读写是由一个线程来完成的，这也是Redis对外提供键值对存储服务的主要流程**。但Redis的其他功能，比如 ``持久化``, ``异步删除``, ``集群数据同步``等，其实都是由额外的线程执行。

### 为什么Redis使用单线程？

**避免多线程带来的并发访问控制问题**：系统通常情况下会存在多个线程同时访问同一个共享资源，当这个共享资源的信息被同时修改的时候，就需要有额外的同步机制进行保证资源的正确性，而这个额外的机制就会带来额外的开销。为避免这些问题，Redis直接采用单线程模式。

![](https://static001.geekbang.org/resource/image/cb/33/cbd394e62219cc5a6d9ae64035e51733.jpg)

### 单线程Redis为什么这么快？

Redis大部分操作都是在内存上进行执行的，再加上Redis使用了高效的底层数据结构（比如：跳表，双向链表，Hash等），除了这些点之外，Redis还使用了 **IO多路复用机制** 使Redis能并发同时处理大量的客户端请求，实现高吞吐率。

#### 基本IO模型与阻塞点

**基本IO模型**：如：为处理一个Get请求，服务端需要监听客户端请求 **(bind/listen)**, 和客户端建立连接 **(accept)**, 从socket中读取请求 **(recv)**, 解析客户端发送的请求 **(parse)** ，根据请求类型读取键值数据 **(get)**，最后返回数据给客户端, 即向socket 中写回数据 **(send)**。

如下图所示，在这个网络IO整个链路中，其中 bind/listen、 accept、 recv、 parse 和 send都属于网络IO处理，而get属于键值对数据操作。既然Redis是单线程的，那么，最基本的一种实现是单线程依次对执行上面的操作。

![Redis基本IO模型](https://static001.geekbang.org/resource/image/e1/c9/e18499ab244e4428a0e60b4da6575bc9.jpg)

#### 非阻塞模型

在socket模型中，不同操作调用后会返回不同的套接字类型。socket()方法会返回 **主动套接字**，然后调用 listen() 方法，将 **主动套接字** 转化为 **监听套接字** ，此时Redis可以监听来自客户端的连接请求。最后，调用 accept() 方法接受到达的客户端连接，并返回连接套接字。

![Redis套接字类型与非阻塞设置](https://static001.geekbang.org/resource/image/1c/4a/1ccc62ab3eb2a63c4965027b4248f34a.jpg)







